----------
Friday 2019-05-03

- continue software installs
  - cocos2d-x version 3.17.1 downloaded and windows symlinks created
    * NOTE: symlinks created in windows has subtle differences compared to linux, and require absolute filepaths
  - updated android ndk
  - install python 2.7.x (cocos2d-x prerequisite)

- added existing cocos2d project (celestial) to github from crouton/linux to windows 10 environment

  * NOTE 1: need to modify line of "proj.android > gradle.properties" to
    PROP_BUILD_TYPE=ndk-build

  * NOTE 2: project path needs to avoid spaces

----------
Wednesday 2019-05-01

- windows software stack:
  x chrome browser
  x visual studio code
  x git
  x android studio
  x android ndk c++
  x cocos2d-x
  - box2d software

----------
Monday 2019-04-22

- finally purchased a moderately powerful, budget-minded pc
  - refurbished + upgrades ~$500
  - this pc has windows 10 installed and currently planning to use this for primary workflow

- currently setting up software stack and backup strategy
  - stack:
    - docker?
    - android studio
    - java
    - android ndk c++
    - cocos2d-x
    - chrome browser
    - box2d software
    - visual studio code
    - text editor or c9.io alternative

  - backup:
    - delete temporary files (clear space)
    - file history (files)
    - system restore
    - macrium reflect (drive/partition backup; TODO: need macrium reflect USB boot drive)

----------
Tuesday 2019-04-09

- it's been ~1 month since I've worked on this (moving into my apartment mostly); reviewing last few journal entries

* issues
  - c9 ide will be shutting down free tier unless subscribing to aws plan
    - I need to download ALL my source code AND find a solution to replace my note-taking
  - a cheap pc might be a good idea

----------
Tuesday 2019-03-05

- adding a menu select scene for the box2d implementation to test out different box2d scenarios
  * after typing some code for this, I have to wonder if the static "createScene()" method is really necessary
    - as stated in previous notes, inherited classes cannot override static methods of the base class. "createScene()" is basically a wrapper for "create()", but if nothing "extra" is being added, is it really worth doing this? to be on the safer side maybe it is

----------
Monday 2019-03-04

- Box2D test harness (SKIP FOR NOW)
  - FAILED attempting to build this from downloaded source code; premake5 had to be downloaded, but still failed - I think because the opengl version is 3.0 and version 3.3 (minimum) is required; not sure if opengl version can be updated on this older chromebox AND I'm not even sure if this is the reason for the error
  - skip the test harness for now until a newer PC environment can be used

- I've starting looking at alternatives because of the box2d test harness problem
  - possibly installing linux on one of the chrome devices (gallium or manjaro..)

  DEVICE 1                            DEVICE 2
  chromebox cn60                    | chromebook c720-3404
  i3-4010U CPU @ 1.70GHz (Haswell)  | i3-4005U 1.7 GHz
  16GB ram                          | 4GB ram
  ~120GB storage                    | 32GG storage

----------
Sunday 2019-03-03

- PROJECT IDEA: rolling coins - various coin rolling w/ accelerometer; international coins maybe? modes - $1.00, $0.50, collector, international (by country), bitcoin, arcade

- b2Sprite test
  - experimenting with scheduleOnce() function to delay movement of asteroid and I encountered problems compiling until I added float dt as an additional parameter -- required; dt is the delay time from when the function was initially scheduled

  - how to implement the refresh button; I've noticed 2 methods 1) menuItemImage (default project close) and 2) standard sprite(s) with touch listeners (eskimo)

    - I decided to go with menuItemSprite which was similar to the menuItemImage implementation, but allows me to use pre-defined sprites from the spritesheet

  * SUCCESS; this implementation test is more or less complete with multiple layers, 2 separate layers for the b2Sprite (physics and graphics), a refresh menu item, and a basic test of box2d with 2 colliding asteroids. while I could go further, adding more asteroids and a more complex scenario, this is enough to verify the capabilities I want to use so far. use this code base as a base template to further evolve

----------
Saturday 2019-03-02

- created 1 falling asteroid b2Sprite with combined graphic/b2Body and placed a "refresh" icon graphic

- NOTE: having multiple cocos2d-x projects reside in the project launcher and switching between projects (Eskimo and Celestial today) sometimes causes those projects to break, but I'm not sure why. Rebuilding those projects and moving requisite resources, source code and .mk files fixes things, but this is very time-consuming. I'm going to only have 1 project "loaded" in the pre-launch screen to see if that fixes things; not a real solution, but if it works that's fine.

----------
Friday 2019-03-01

- created a spritesheet .plist using texturepacker/polygon shapes + spaceship sprites and using this in my box2d test

- goal:
  - create multiple box2d rotating "asteroids" that collide ~ about 3
  - a refresh button that resets starting positions

----------
Thursday 2019-02-28

- noting similarities between classes that inherit from b2Sprite (minipool/ball, minipool/cue, eskimo/eskimo, eskimo/platform) in hopes of better understanding b2Sprite usage and making a similar class to use as a template

  cue
  - constructor - b2Sprite initializer
  - destructor - empty
  - create (static) - entry point to create object (similar to Sprite::create())
    - initCue - init physics + shape, init sprite image

  ball
  - constructor - b2Sprite initializer, init private variables
  - destructor - empty
  - create (static) - entry point to create object (similar to Sprite::create())
    - initBall - init physics + shape + position, init sprite image
  - reset - reset physics + position + private vars

  - update(dt) - update sprite position to match physics
    - NOTE: b2Sprite already has update(dt) and this appears to override this with the key difference being that angle is not altered with ball::update()

  eskimo
  - constructor - b2Sprite initializer, init private variables, init physics + shape, init sprite image
  - destructor - empty
  - create (static) - entry point to create object (similar to Sprite::create())
  - reset - reset physics + shape + angle
  - update - switch physics shape
  - makeCircleShape - create circle physics + image
  - makeBoxShape - create square physics + image

  platform
  - constructor - b2Sprite initializer, init physics, register custom notifications
  - destructor - empty platform container
  - create (static) - entry point to create object (similar to Sprite::create())
    - createTiles - platform container composition
  - initPlatform - PUBLIC; complex composite object; init physics + shape + position + angle
    - switchTexture - init sprite tiles

- modified my version of b2Sprite and added setPosition (overloaded) + setRotation + setTransform

----------
Saturday 2019-02-23

- attempting to understand b2Sprite usage

  - b2Sprite composition allows bidirectional reference to b2Body/b2Sprite
    - b2Sprite->b2Body <===> b2Body::userData->b2Sprite

  - b2World ==> b2Body <= b2BodyDef
                       <= b2Fixture <== b2 "Shape"

  - while browsing code I noticed 2 variations on initializing a Sprite from a sprite frame
    - createWithSpriteFrameName VS initWithSpriteFrameName
    - no reasonable explanation could be found regarding usage of one over the other, even looking at the code didn't help
    - initWithSpriteFrameName tended to be used within a class inheriting from b2Sprite
    - createWithSpriteFrameName seemed to be used more standalone..


  MINIPOOL
  * pocket x 6
    - though defined as a b2Sprite and it works, this doesn't make sense since there's no sprite involved
    - I'm pretty sure the pockets could be coded similar to the table sides ..as b2Body objects

  - ball x 15 + cue ball
  * cue stick (good example)

  ESKIMO
  - eskimo
  - platform x 50

----------
Friday 2019-02-22

- box2d test
  - created a physics-only layer with debug draw code (conditional compile), basically refactoring it out of the scene and into a custom layer
  * the drawing on physics debug layer honors proper z-order when tested against other layers with graphics stacked in nearby proximity
  - modified code to test a slow falling circle with Layer update called from the Scene update
    - tried @ 30fps just for fun.. I might try this again in the future further along; I wonder if this affects battery drain

- b2Sprite.h/.cpp
  - created a slightly modified version of the b2Sprite class from the minipool book sample application
  - NEXT: try using b2Sprite in the box2d test with box2d-only b2Sprite and graphic+box2d b2Sprite

----------
Thursday 2019-02-21

- box2d test
  - copied GLES-Render.cpp/.h from minipool (I'm not sure if there's a better version??)
  - copied box2d/GLES debug code with no gravity a simple physics body circle as a test - this worked after some minor issues
    - debug draw code uses a conditional compile flag to simplify enabling this feature
    - positioning works as the circle was made to draw on the center of the screen using PTM_RATIO

  * next, I think that this box2d/debug draw code needs to refactored onto the physics Layer instead of directly on the Scene as it is now AND if everything still works, try adjusting the z-order with the graphics layer above or below; and after that, a custom b2Sprite

----------
Sunday 2019-02-17

- created basic box2d framework in the test application

  - playing around with compiler flags to control the box2d debug draw
    - a common #include with #define is probably best

- still in the early stages.. I created a PHYSICS_DEBUG flag.. continue building on this

- currently @ Intown Suites due to personal problems, but it's difficult to work on this

----------
Saturday 2019-02-16

- created a very basic scene with multiple layers. the following describes how scene/layers are handled currently vs. my intended goal

  DEFAULT PROJECT: scene with no layers

  MINIPOOL / ESKIMO: 1-1 scene/layer hybrid with scene "hidden"

  GOAL: scene with 1+ layers
  - scene automatically should load required layers
  - easy ON/OFF of each layer's visibility

  - possible layers
    - PHYSICS LAYER
    - GAME LAYER
    - HUD LAYER
    - MENU LAYER

  - PHYSICS LAYER should have the highest z-order

----------
Saturday 2019-02-09

- skimmed Cocos2d-x by Example - ch.5
  - this is a bit more involved than I first thought, especially the math involved

----------
Thursday 2019-02-07

  TexturePacker tutorial

  - https://www.codeandweb.com/texturepacker/tutorials/animations-and-spritesheets-in-cocos2d-x

  - how to create a sprite sheet specific to cocos2d-x with scaled variant resolutions (hdr/hd/sd) and polygon outline sprites

  - sample project and source code
    * NOTE: it might be worthwhile to compare the source code for loading resources against previous methods

  - author recommends using highest design resolution

  * a cocos2d-x Vector of sprite frames is created using "HelloWorld::getAnimation()" and uses an interesting method "sprintf()" + a unique naming scheme in the .plist data file to load animation sprite frames

    sprintf
    - write formatted data to string
    - http://www.cplusplus.com/reference/cstdio/sprintf/

  - one unique recommendation is to MAKE THE SPRITE ANIMATION A CHILD OF THE BACKGROUND IMAGE as opposed to the layer; this ensures that the sprite is positioned in the right spot on the background

  - adding a MoveTo sequence with the walking animation makes 2d animation more convincing
    - COMMENT: I had to add an additional 5 seconds to make the feet not slide too much; the movement didn't match the walk's stride

----------
Wednesday 2019-02-06

- looking at code from "MyTests" and adding to notes from "Friday 2019-02-01"

----------
Monday 2019-02-04

- still reviewing previous notes from "Wednesday 2019-01-16"

- TODO: I need to go through these notes again another time and incorporate some of the info into "topics - main.txt" and "Box2D.txt"
  - ditto for "Building Android Games.txt" and "Cocos2d-x by Example.txt"

- I was just curious about using json instead of .plist/xml and google search "cocos2d-x json" pointed to using the "rapidjson" external library

----------
Sunday 2019-02-03

- finished notes for Cocos2d-x by Example - ch.4 Sky Defense and reviewing notes as a refresher

- looking back at my box2d notes and the minipool code, I'm still not exactly sure how I'm going to implement the box2d/debug-draw
  - after studying minipool codebase, something similar to the following object structure is required
    - a scene with a regular "GAME SPRITES" layer + "BOX2D PHYSICS / DEBUG DRAW" layer (higher z-order)
    - an object similar to CUE.CPP/.H derived from b2Sprite
    - something similar to B2SPRITE
      - b2Sprite needs 2 separate layers in the constructor: a GAME LAYER and a PHYSICS LAYER
      - in addition, further refine "b2Sprite::setSpritePosition()"

  * NOTE: the minipool implementation is rather complicated to understand and modifying it to support 2 layers seems even more daunting

----------
Friday 2019-02-01

- Cocos2d-x by Example - ch.4 Sky Defense


  SPRITE SHEETS

  - the MAX TEXTURE SIZE that seems to be a safe choice for most devices seems to be 2048x2048
    - 4096x4096 for newer devices

  - create a sprite sheet optimized for cocos2d-x using TexturePacker
    - https://www.codeandweb.com/texturepacker/tutorials/animations-and-spritesheets-in-cocos2d-x

  - "SpriteBatchNode" though technically not deprecated, doesn't seem encouraged, and still exists for compatibility
    - this book's sample code uses SpriteBatchNode extensively
    * according to "https://www.codeandweb.com/texturepacker/tutorials/cocos2d-x-performance-optimization", SpriteBatchNode will only use quads and ignore polygon optimized sprites

  - when shrinking/growing a sprite regularly (ex. bombs in this game) it may be beneficial to create a MIPMAP for performance
    * use ->getTexture()->generateMipmap() to create antialiased pre-rendered copies of a texture in diminishing sizes
    - texture must be POT (power of 2)
      - QUESTION: does POT refer to the source texture file or the texture frame?


    ADDING SPRITES

    - SpriteFrameCache::addSpriteFramesWithFile() now inherently handles batch drawing of sprites
      - this is an overloaded method that loads the .plist/.png texture

    - use Sprite::createWithSpriteFrameName() to create new Sprites from texture file "frames"

    - use Sprite::create() + AutoPolygon on plain .png textures (see "MyTests" project)
      - AutoPolygon creates a polygon "cutout" shape of a sprite to make drawing more efficient; more vertices, fewer pixels
      - see: https://docs.cocos2d-x.org/cocos2d-x/en/sprites/polygon.html

      example:

        auto poly_data = AutoPolygon::generatePolygon("hula.png");
        auto hula_sprite = Sprite::create(poly_data);

      - while AREAS OF A SPRITE SHEET CAN BE SPECIFIED BY THE 2ND PARAMETER of Autopolygon::generatePolygon(), it's BEST WHEN ONLY A SINGLE FRAME IS NEEDED as ::generatePolygon() is a static function the doesn't allow a sprite texture to be re-used

      * when MULTIPLE FRAMES OF A SPRITE SHEET ARE NEEDED TO BE REDUCED IN-CODE, see "cocos/2d/CCAutoPolygon.h" comments for "generateTriangles()"; AutoPolygon can be re-used multiple times with different settings for ::generateTriangles()

      * for sprite sheets created with TEXTUREPACKER, the software can create "POLYGON MESH SPRITES" that export cocos2d-x .plist format
        see: https://www.codeandweb.com/texturepacker/tutorials/cocos2d-x-performance-optimization


    - inherited from Node

      * set the sprite z-order using the 2nd parameter of ->addChild()
        - ex. enum: foreground, middle, background, etc.

      * create an optional TAG identifier using the 3rd parameter of ->addChild()
        - retrieve said child object using ->getChildByTag(< tag >)

    * SPRITES CAN BE CHILDREN OF OTHER SPRITES because each sprite is based on Node
      - game example uses the bomb with child sprites for the sparking fuse and halo effect
      - NOTE: shrink / grow container will also affect children


  BITMAP FONTS

  - font image file (.png) + font data file (.fnt)
    - the .fnt file contains the file name of the relevant font image file

  - use Label::createWithBMFont(< font data file >) to load the bitmap fonts

  - adjustment can be made to the anchor point
  - use ->setString() to change the actual text of the relevant label


  OBJECT POOLS

  - pre-allocation of memory for re-usable objects for efficiency / speed

  - usually based on cocos2d-x Vector class if using Ref-based cocos2d-x objects as this automatically handles ref counts, etc.
    - class wrapper based on std::vector

    - pre-allocate size in the relevant class constructor
      - ie. GameLayer::GameLayer() : _meteorPool(50), _healthPool(20), _fallingObjects(40), _clouds(4) {...

    - .clear() method is probably best for clean up

    * be cognizant of reaching the end of an object pool and handling that scenario


  ACTION / ACTION SEQUENCE / ANIMATION

    ACTION: node transformation over specified time interval
    - many transformations are a subclass of the Action class (ie. FadeOut, ScaleTo, RotateBy, etc.)
    - defined by "Action::create()" and usually with a time interval

    * remember to use "->clone()" when RE-USING ACTIONS
      - see: http://www.cocos2d-x.org/docs/cocos2d-x/en/actions/sequence_internals.html

    - ACTIONS are time savers compared to trying to implement them otherwise
      * example of NOT USING ACTIONS and the code to implement this can be found in "// move clouds" section of GameLayer::update()
      - whereas the falling meteors is an example of USING ACTIONS


    ACTION SEQUENCE: combination of pre-defined actions and animations AND OTHER ACTION SEQUENCES
    - action EASING EFFECTS (ie. EaseIn, EaseOut, etc.)
    - action REPEAT (ie. Repeat, RepeatForever)
    - action CALLBACKS can be specified upon completing an action
      - implemented with CallFunc / CallFuncN; CallFuncN has Node* as the 1st argument of the callback function

      ex. 1

        CallFunc::create(std::bind(&GameLayer::shockwaveDone, this))..
        void GameLayer::shockwaveDone() {..}

      ex. 2

        CallFuncN::create(CC_CALLBACK_1(GameLayer::animationDone, this))..
        void GameLayer::animationDone(Node* pSender) {..}

    * execute an action with "->runAction(< Action | Action Sequence >)"

    * see sample code function "void GameLayer::createActions()" for implementation examples
      - ch.4 Sky Defense pre-defines many Action Sequences into class variables and uses "->retain()" for easy re-use whenever needed (ie. explosions, explosion shockwave, healthpack parachute fall/swing, etc.)


    ANIMATION: changes the texture used by a sprite over a period of time that can create the effect of animation

    - animation initialized with "Animation::create()"
    - add sprite frames using "->addSpriteFrame()"

    - OR "Animation::createWithSpriteFrames()" with cocos2d-x Vector of sprite frames (see MyTests project)

    - set frame delay time using ->setDelayPerUnit(< # seconds / # frames >)
    - go back to start frame after the animation is complete using "->setRestoreOriginalFrame()"

    - NOTE: animation object can be re-used for multiple animations
      - book example does this for "_explosion" and "_groundHit"

    - implement the animation as an ACTION with "Animate::create(< animation >)", which can then be incorporated into an ACTION SEQUENCE


    SPAWN: simultaneous actions or sequences
    - see "Spawn::createWithTwoActions()", "Sequence::createWithTwoActions()", and similar functions


  UPDATE TIMERS
  - several in-game count-up "timers" and "timer intervals" are implemented as float counters to activate in-game events
  - though these timers are a bit simple, this technique obviously works, but I'm not sure if there's a better way

----------
Thursday 2019-01-31

- tried opening sprite_sheet.png/.plist in TexturePacker without luck, but discovered TexturePacker projects have their own file format; the best I could do is "add" the .png to an existing project

----------
Tuesday 2019-01-29

- Cocos2d-x by Example - ch.4 Sky Defense continued reading
  * cocos2d-x Sprites can be children of other sprites such as the bomb

  - the "final" code version closely resembles what's presented in the book
  - the "bonus" code actually includes the ufo enemy; there are a number of areas where the code is implemented differently

----------
Monday 2019-01-28

- I decided to go through the reading for ch.4 Sky Defense and build the demo
  - while creating this demo, it's interesting to note that ch.4 has 3 versions of the source code - start, final and bonus

----------
Sunday 2019-01-27

- continued Cocos2d-x by Example - ch.9 Eskimo from custom user events

- as this daily journal increases in length to ~900+ lines, I've decided to separate it for easier organization and to reduce memory footprint

- the Eskimo game also uses "SpriteBatchNode*" similar to MiniPool; it might be a good idea review ch.4 Sky Defense as this is where this topic is first addressed

----------
Saturday 2019-01-26

- continued Cocos2d-x by Example - ch.9 Eskimo

* one item I would like to focus on are the CUSTOM USER EVENTS (I think), specifically for use with JNI and the various android sensors (light, audio, gyro and linear acceleration)

- read through CUSTOM USER EVENT section to better understand this topic.. I still need to write notes on this section

----------
Friday 2019-01-25

- continued Cocos2d-x by Example - ch.9 Eskimo

----------
Wednesday 2019-01-23

- created ch8 Eskimo project

  - creating a project by manually copying resources and c++ source files, then modifying Android.mk failed; I couldn't determine what the error messages even meant

  * I tried again and succeeded creating the Eskimo project by creating a base "HelloWorld" project, opening it in Android Studio, copying the resource and c++ files, modifying Android.mk, and then selecting "refresh linked c++ projects" in Android Studio
    - after ~10+ min the project compiled and successfully ran on the hp touchpad (~40fps and the accelerometer controls seem inverted)
    - tried running on the moto g (60fps and correct motion controls)

  - "pause" feature worked as expected, but the music kept playing
  - tutorial seemed like a good idea, but there was no apparent way to exit the tutorial and play the actual game
  - ran at decent 34-40 fps, good background music and seemed almost "professional", but the control scheme's tricky guiding of the eskimo to the igloo seemed unintuitive / clunky


- Cocos2d-x by Example - ch.9 Eskimo

  - several topics already mentioned:
    - box2d, scene transitions, .plist, load / save data, accelerometer
    + particle effects, custom notification/events, singleton layer

  ---
  BOX2D
  - eskimo can switch shape, each shape having distinct physics properties

  - eskimo and platform(s) are derived from b2Sprite (custom Sprite + b2Body class)
  - gravity switch (GSwitch) and igloo are derived from Sprite

  * the eskimo can collide with gravity switches and igloo
    - this game DOES NOT USE BOX2D SENSORS like ch.8 minipool
    - demonstrates 2d collision logic without having to use to box2d sensors
      - collisions are determined in the games main loop combined with user-defined events to handle the collision logic

    "compound body" - a box2d body with multiple fixtures
    - a box2d "body" may have 0 - n box2d "fixtures"
      - this can be a mix of sensors and solid fixtures

    - box2d "fixtures" can contain (see box2d docs 7.1)
      - a SINGLE shape (or none..)
      - broad-phase proxies (?)
      - density (mass), friction (objects sliding each other), restitution (bounce)
      - collision filtering flags
      - back pointer to the parent body
      - user data
      - sensor flag (collision detection with no response)
      ---
      - fixture definition (b2FixtureDef) contains creation info with defaults
      - fixture is created as part of a body; cannot exist independently
      - destroyed automatically with the parent body or can be destroyed separately

  ---
  SCREEN ORGANIZATION (3 layer/scene(s))

  * COMMENT: this seems a good method for prototyping
    - start with some thumbnails + simple description + flowchart(?)

  - menu | level select | game
    - layer is based on cocos2d-x "Node"
    - like android "activities"; each layer/scene exists independently in memory

    - structure
      - menu
        -> static cocos2d::Scene* scene()

      - level select
        -> static cocos2d::Scene* scene()

      - game
        -> static cocos2d::Scene* scene()
          -> static GameLayer* create(int level, int levelsCompleted)
            -> void clearLayer(void);

    * game layer/scene, unlike the others, is a singleton (pointer) that stays in memory once instantiated, speeding up repeated scene loads

      - TRANSITIONS to game layer/scene are treated exactly the same as any other scene

      - NOTE: GameLayer::clearLayer() hides all level platform and gravity switch sprites and inactivates all platform physics bodies - if the game layer/scene is already loaded in memory

      - architecture

        - PRO/CON #1: scheduleUpdate() and unscheduleUpdate() have to be called to control the MAIN LOOP
          - ENTRY POINT scheduleUpdate() - from GameLayer::create()
          - EXIT POINT unscheduleUpdate() - from GameLayer::onTouchEnded() when transitioning to the Menu scene/layer

        - PRO/CON #2: transitioning to a new instance of GameLayer is not possible

        * NOTE: the author mentions that this singleton architecture obviously works, but PERHAPS A BETTER ALTERNATIVE is a game elements cache or "game manager" constructed with singleton object pools to better allow sharing of game elements between scenes and still take advantage of the increased loading speed

    * game layer/scene CONSTRUCTOR + sub functions, DECONSTRUCTOR, and CREATE + sub functions should be studied a bit more thoroughly to better understand relationships involved

    - another example @ cocos2s-x: tests/cpp-tests/Classes/TransitionsTest
      - COMMENT: this is about layers, not the hybrid scene/layer ..without digging deeper into the code, I'm not sure exactly how this helps

    * layer->release(); is used when creating new scenes; many other examples don't do this ..is this better? why?

    *** NOTE: the menu layer doesn't have touch listeners assigned to any particular function; SO WHY IS THAT? ***

  ---
  LOADING EXTERNAL LEVEL DATA USING .plist

  - xml-format (can be edited in any text editor -- I've read some conflicting info on this though)
    - more dedicated .plist editor?

  - stored in Resources folder

  - RECOMMENDATION: limit the size of .plist files and organize into multiple level "packs" to reduce memory footprint and speed up load/parse step

  - the main item types for .plist is either array (many indexed elements of the same type) or dictionary (many named elements of varying type), + boolean, data, date, number, string individual elements

  - code sample to load .plist to load the level data

    _levels = FileUtils::getInstance()->getValueVectorFromFile("levels.plist");

    - note that "getValueVectorFromFile()" returns a ValueVector ARRAY type and is NOT DOCUMENTED online for some reason
    - QUESTION: is the "root" element always an array type?

  - parsing data uses "ValueMap" for maps, "ValueVector" for arrays, and .asInt()/.asBoolean()/.asString() etc. for other elements

  ---
  SAVING GAME DATA WITH UserDefault

  - easiest method to save user data is with UserDefault
  - able to get/set/delete individual key/data elements - integer, float, string, boolean
  - more efficient to use .flush method for multiple updates and find a strategic point in code to execute this

  ---
  USER-DEFINED EVENTS

  - Director + Dispatcher
    - a central message dispatcher (OBSERVER PATTERN) - other objects can subscribe to in order to listen or dispatch messages to

  - EVENT HANDLERS for "custom" user events are special functions created specifically for dealing with user-defined event triggers
    * COMMENT: despite their usefulness, some of these techniques tend to obfuscate what's actually going on behind the scenes


    EVENT HANDLERS
    - c++ LAMBDA EXPRESSION derived functions are used to create custom EVENT HANDLERS (for Platform and Igloo classes)
      - TODO: LAMBDA EXPRESSION usage needs to be studied in a bit more detail

      - these are placed somewhere near the actual "add listener" for improved readability (OR can be written directly in-place)
        user docs example: https://docs.cocos2d-x.org/cocos2d-x/en/event_dispatcher/custom.html


    ADDING USER-DEFINED EVENT LISTENERS
    - custom macros (EVENT_DISPATCHER and ADD_NOTIFICATION) are combined in such way to greatly simplify the syntax

      ADD_NOTIFICATION(this, GameLayer::NOTIFICATION_GRAVITY_SWITCH, onGravityChanged);

      vs.

      Director::getInstance()->getEventDispatcher()->addEventListenerWithSceneGraphPriority(EventListenerCustom::create(GameLayer::NOTIFICATION_GRAVITY_SWITCH, onGravityChanged), this);

    - no luck trying to implement this using CC_CALLBACK_2 -- I'm not sure how to do this or if it's possible


    NOTIFICATION DISPATCH
    - custom macro can once again be used to simplify syntax

      EVENT_DISPATCHER->dispatchCustomEvent(GameLayer::NOTIFICATION_GRAVITY_SWITCH);

    - "->dispatchEvent()" can also be used, but isn't as convenient


    MESSAGE NOTIFICATIONS
    - implemented as static const c-strings

      const char* GameLayer::NOTIFICATION_GRAVITY_SWITCH = "NOTIFICATION_GRAVITY_SWITCH";


    CUSTOM EVENT USER DATA
    - void* data type
    - data can be retrieved from EventCustom* parameter of the EVENT HANDLER

      event->getUserData();

    - user data can be set in the optional 2nd parameter of dispatchCustomEvent()
      - event->setUserData(void* optionalUserData) is called internally


    REMOVING EVENT LISTENERS
    - book states that event listeners are removed automatically once that parent object is destroyed

    - in the Igloo deconstructor, however, the customer user event listeners are removed explicitly

      EVENT_DISPATCHER->removeCustomEventListeners(GameLayer::NOTIFICATION_GRAVITY_SWITCH);

  ---
  ACCELEROMETER

  - overall, the use of the accelerometer isn't much different when compared to ch.4 - Building Android Games with Cocos2d-x

  - this code is still using the built-in accelerometer API, limiting it to acceleration+gravity only

  - digging into the java code for android (Cocos2dxHelper.java, Cocos2dxAccelerometer.java), it appears that onPause()/onResume() automatically handles enabling/disabling the accelerometer


    INITIALIZATION
    - turn the accelerometer on/off

      Device::setAccelerometerEnabled();


    INTERVAL
    - control the event interval (ie. 1/60, etc.); not sure if this would affect battery life

      Device::setAccelerometerInterval();


    EVENT BINDING
    - a special event listener object is required, "EventListenerAcceleration", but is implemented in a similar fashion to other event objects

      auto listenerAccelerometer = EventListenerAcceleration::create(CC_CALLBACK_2(GameLayer::onAcceleration, this));
      _eventDispatcher->addEventListenerWithSceneGraphPriority(listenerAccelerometer, this);


    IMPLEMENTATION / USAGE NOTES

    - BEST PRACTICES
      - minimal processing logic is implemented in the event handler and basically, raw acceleration data is copied to member variable (at least in this book anyway)
      - most logic processing is done in the main loop

    - game-specific Box2D integration
      - acceleration control is limited to when the eskimo is "touching" a platform

        if (_player->getBody()->GetContactList()) ..

      - eskimo shape determines the type of force applied

        - if the eskimo is a circle, a constant force is applied
          * ideally, I think that friction should have an effect automatically, but the friction effect appears to be applied independent of box2d on the velocity and I'm not sure why..

          _player->getBody()->ApplyForce(b2Vec2(_acceleration.x * CIRCLE_MULTIPLIER, 0), _player->getBody()->GetWorldCenter(), true);

        - if the eskimo is a square, an impulse is applied, with no friction effect

          _player->getBody()->ApplyLinearImpulse(b2Vec2(_acceleration.x * BOX_MULTIPLIER, 0), _player->getBody()->GetWorldCenter(), true);

  ---
  REUSING b2Body

  - box2d makes it possible to change fixture data of a b2Body fixture without having to destroy the actual body
  - this game makes use of this feature with the eskimo shape change and also with the platform layout with each new level

  - the following code snippet allows re-using b2body by destroying any existing fixtures

    if (_body->GetFixtureList()) {
      _body->DestroyFixture(_body->GetFixtureList());
    }