Sunday 2019-06-30

  re-watch rube tutorial videos
  - taking so long.. I think because I just watched @ 1.5x last time without taking notes
  ..just 2 left; going to skip v1.6 update until tomorrow or Tuesday as v1.7 has what I'm interested in I think


  ** I'm thinking about using custom data for my settings via CUSTOM PROPERTIES (see RUBE.txt) and/or USER DATA (see "Monday 2019-05-27" - "user data" box2d test harness (iforce-UserDataTest.h) ==> location: D:\SDK\Box2D\Testbed\Tests)

    - not sure if CUSTOM PROPERTIES and USER DATA are related or are one and the same, but I'll have to dig deeper into the code to find out
    
    - just a note, but the RUBE editor allows for "CUSTOM PROPERTIES", but not "USER DATA" in it's pure definition as a void* so...

    - my use case: min/max, default value, label, description, intended toy width/height (for c++ layout)
      - this does an end-around cocos2d-x, but that's not a bad thing


    INSTANTIABLE OBJECTS
      - I probably need to think about this some more, especially with the scaling joint parameter issue
        - my turtles for example - the big turtle's joint strength would be different from the smaller ones
        - it might be better to have duplicates of items that maintain it's original scale..maybe
        - the 3 baby turtles could easily be an instance of 1, with the adult being a separate file altogether..

      - I need to consider this from MULTIPLE PERSPECTIVES: the RUBE editor, RUBE json export, c++ b2dJson import, settings use-case vs multi-toy dashboard use-case

----------
Saturday 2019-06-29

  re-watch rube tutorial videos
    
    TODO - add more info to joint notes

    - watching version update videos.. just a comment. there are SO MANY LITTLE DETAILS that I would definitely have missed had I not re-watched these. also without taking notes, I don't see how I would remember half of this -- not sure if I'll use it all, but..


    - cocos2d-x demo shown for v1.3

      TODO - quick note, check out the code for destroying bodies and reloading (I need to actually try the reload on my current stuff)

      * PINBALL is interesting in some of the pinball paths that can only have an entrance and have a BITPLANE-LIKE effect
      * 2D adventure - take a look at the camera code

----------
Friday 2019-06-28

  updated gimp to v2.10.12

  re-watch rube tutorial video #16 + notes
    - I want to finish re-watching these, specifically to see if I can make re-usable box2d "components"
    - ideally I could use the RE-USABLE COMPONENTS to create composite RUBE/box2d scenes or import the components in directly -- still not sure if this is possible
    - left off at v1.2 updates

----------
Thursday 2019-06-27

  coding

    settings
      - started a settings scene (ultimately intended for application-level settings) for testing out cocos2d-x widgets
      - I'm also thinking about using RUBE/box2d for widgets like in the RUBE demo

      - experimentation with the existing menu, labels, and text fields
        - I can get away with placing textfields and standard sprites as menu items - this doesn't seem to be a standard practice per se, but works
        
        - for now I'm going to try and keep this simple, with checkboxes and textfields only. once I'm further along, I'll go back and implement some more graphically pleasing UI controls
          - I think the RUBE editor, as shown in the RUBE demo, would work somewhat, but I need to be able to constuct settings dynamically per the needs of individual scenes from structured / persisted data -- I THINK
          - HARD-CODING a UI layout purely in RUBE is enticing though

        - the biggest issue I have is with textfields and the color behind it - it doesn't support it by default
          - the best luck I've had is with using a DrawNode-->drawSolidRect behind the TextField

        * TODO - I need to create storyboard-style settings screens
          - sample UI: stocard, smart recorder, when.do
          - remember this is developed in a game-style app, so widgets aren't as robust
          * look at RUBE widget demo code, try creating individual RUBE widget (this knowledge will also help with the "dashboard" concept)


  *** CCCONFIG.H - disabling physics (and adjusting other cocos2d-x api parameters)
    - https://docs.cocos2d-x.org/cocos2d-x/en/physics/debugging.html
      - found this in docs while searching for whether or not I could use scenes created in cocos creator for settings-type layout ..I don't think it's possible

    - location: cocos/base/ccConfig.h
    - ie. enable/disable fps stats interval / location, use tiff/jpeg, 3d physics, etc.

    - VERY INTERESTING; disabling unused features can reduce package size
      - my debug .APK filesize is 4.39MB, disabling some unused options

    - stripped out the following box2d/chipmunk parameters from proj.android/app/jni/Application.mk

      -DCC_ENABLE_BOX2D_INTEGRATION=1 -DCC_ENABLE_CHIPMUNK_INTEGRATION=0
    
      APP_CPPFLAGS := -frtti -DCC_ENABLE_BOX2D_INTEGRATION=1 -DCC_ENABLE_CHIPMUNK_INTEGRATION=0 -std=c++11 -fsigned-char -Wno-extern-c-compat


  cocos creator
    - I was curious about whether I could use this to create UI widgets for my settings screens and combining it with my existing c++ codebase
    - ended up re-installing because of some error and just trying out a "hello world" project
    - I might re-visit this when I'm idle


  re-watch rube tutorial video #15 + notes

----------
Wednesday 2019-06-26

  re-watch rube tutorial video #14 + notes


  audio notes

    - feet on dashboard with multiple solar powered toys
    - add bare feet to hawaiian theme, animated, spread pose

    - "dashboard mode" like what I saw
      - multiple toys on the digital dashboard, with placement and resize(?)
        - for repositioning maybe vibrate feedback, long-press(?), or click the base

      - default to landscape
      - currently only one toy is visible that will be resizable + panning
      - multiple toys physics overhead shouldln't slow performance
      - b2dJson loader would have to import each toy individually; ignore world settings or don't export
      - unlock each toy with ad-movies

    - overlay config options (hud)
      - re-usable
      - appear / fade out
      - landscape or portrait
      - rube layer pointer?

    - don't rely on os orientation, use "in-app" pseudo-orientation?
      - cocos2d-x doesn't support this
      - global and scene-by-scene

    - data storage; user-default or json object
    - settings object; defaults (hard-code or..)
    - menus (scrolling movement)

    - feature-creep.. focus on KISS to complete the app
      - menus, settings, clean up physics and graphics

      - surfboard scene, hula android, standard app requirements (privacy statement, etc.), splash


  live wallpaper
    - android canvas might be a solution for the live wallpaper, but a lot of duplicate code would be required
    * TODO - go back and try modifying Cocos2dxHelper.java again to re-attempt the live wallpaper, and try using android "context" wherever possible and see if it breaks an existing project

----------
Tuesday 2019-06-25

  CODING

    settings screens

      - making a list of settings for reference - settings.txt

      - I considered making framerate as a setting, but after experimenting with it, this doesn't seem like a good idea
        - the max framerate is 60 fps apparently 
        - at 30 fps, sideways movement appears choppy
        - for a mostly static scene, like settings or a menu, setting the framerate low (ie. 20 fps) seems to work, but if implemented, don't forget to reset it to it's prior value


    android live wallpaper
    
      *** MY ATTEMPT TO GET THIS WORKING MORE OR LESS FAILED ***

      - this post describes the situation more or less:
        https://discuss.cocos2d-x.org/t/3-2rc0-android-live-wallpaper/15460

      - I checked in my updates to the "RUBE loader custom" project for future reference (just in case)
        - this contains my live wallpaper modifications except for Cocos2dxHelper.java

      - my implementation has something wrong with starting the actual java service - it always crashes (I didn't figure out the cause, but it's a moot issue). ultimately though, even if that were fixed, the cocos2d-x 3.x framework doesn't really allow initializing the cocos2d-x app from an android service, as an android "Activity" is required at many code points beyond the Cocos2dxHelper.init() function. this is beyond my capability. I also undid my changes to Cocos2dxHelper.java
      - I found a simplified cocos2d-x live wallpaper project in the forums, created/tested that project, but failed on the Cocos2dxHelper.init() from the wallpaper service with errors related to being unable to cast the wallpaper service "Context" to and "Activity"


      * it might be worth pursuing a pure android solution with java AND c++
        CON: duplicate c++/java code?
        PRO: re-use RUBE/box2d physics and assets

        - the vogella code from "Sunday 2019-06-23" is probably the best place to start
          - see the android studio project "Vogella_LWP" in the code backup

        - https://github.com/jbox2d/jbox2d
        - https://github.com/iforce2d/b2dJson
          - https://www.iforce2d.net/rube/?panel=loaders
        - https://developer.android.com/reference/android/graphics/Canvas.html
        - http://gamecodeschool.com/android/coding-android-sprite-sheet-animations/ (maybe?)


      - an interesting read re: native opengl and android live wallpaper (way too complex for me though)
        - https://mycardboarddreams.wordpress.com/2017/02/25/making-a-live-wallpaper-in-native-opengl/

----------
Monday 2019-06-24

  CODING

    android live wallpaper
      - attempt cocos2d-x integration using "RUBE loader custom" project
      - I went ahead and put this in github
      - I chose this project as it has accelerometer-controlled physics and has only one scene ..this will eventually need more than one scene though

      * I need to make a note of this for future reference; Cocos2dxHelper.java needs to be modified in order to enable the android live wallpaper feature, specifically, an overloaded version of init() in Cocos2dxHelper.java needs to be created that will allow an android wallpaper service to start up the cocos2d-x app. the existing version of init() needs to be kept, but it only allows an android activity to start the cocos2d-x app. the following is the path:

        - ..cocos2d\cocos\platform\android\java\src\org\cocos2dx\lib\Cocos2dxHelper.java

        **** Cocos2dxHelper.java WOULD NEED TO UPDATED APPROPRIATELY WITH EACH NEW RELEASE OF THE COCOS2D-X API ****

----------
Sunday 2019-06-23

  CODING

    android live wallpaper

      - I wanted to get a better "feel" for live wallpapers from standard android projects and then try it with the cocos2d-x framework..


      https://www.vogella.com/tutorials/AndroidLiveWallpaper/article.html

        2.3 java code example to use an intent to set the wallpaper

        * AndroidManifest.xml >>> android:exported="true" also used here
        - uses deprecated methods for preferences, whereas the matrixLWP used code fragments - I'm not sure it matters though; ideally I would like to launch my cocos2d-x app straight into live wallpaper config screen


      https://www.codeproject.com/Articles/1167401/Android-Live-Wallpaper-Tutorial

        - live wallpaper finally created, but text doesn't fall
        - sub-project "colorPicker" REALLY COMPLICATED things

        * AndroidManifest.xml >>> android:exported="true" must be specified on the settings activity for it to open when clicking SETTINGS button (TESTED - SEEMS IRRELEVANT..)


      https://kb.phardera.com/2013/07/create-android-live-wallpaper-with.html

        - not much explanation behind the actual live wallpaper, except basic stuff
        - "flocking birds"
        - default project wouldn't compile, so I didn't bother trying to implement

        .java files
          * android.app.WallpaperManager

          * android.service.wallpaper.WallpaperService
            - the base class for all live wallpapers


        AndroidManifest.xml
          * <uses-feature android:name="android.software.live_wallpaper" android:required="true" />
            - NOTE: android:required - it might be useful to set this FALSE for my stuff

            <service ..
          *   android:permission="android.permission.BIND_WALLPAPER
              <intent-filter>
          *       <action android:name="android.service.wallpaper.WallpaperService" />
              </intent-filter>
          *   <meta-data android:name="android.service.wallpaper" android:resource="@xml/mylwp_main" />
    

    standard android "hello world"
      - https://developer.android.com/courses/fundamentals-training/toc-v2

      NOTE: while creating the project I noted the following android api level features that caught my eye

        api level 7 - live wallpaper
        api level 17 - DAYDREAM, SECONDARY DISPLAYS, and LOCKSCREEN WIDGETS
        api level 18 - support for opengl es 3.0
        api level 21 - support for opengl es 3.1
        api level 24 - multi-window support, vulkan api, vr mode
        api level 25 - enhanced live wallpaper metadata
        api level 26 - multi-display support

----------
Saturday 2019-06-22

  ANDROID LIVE WALLPAPER / WIDGETS

    - I bookmarked several internet resources for creating android live wallpapers and widgets
    - another was a standard android live wallpaper, but had an interesting take on a "flocking birds" algorithm that I might be able to use for the hawaiian turtles - https://www.developer.com/ws/android/building-an-android-live-wallpaper.html

----------
Friday 2019-06-21

  CODING

    - moved sensor cached data over to SensorManager instead of the GameManager; it seemed to make more sense to be grouped there

    * linear acceleration calculated using low-pass filter (see code for notes)
      - for devices reporting a hardware linear accelerometer, that is used, but if unavailable, the linear acceleration is calculated based on a low-pass filter method of the accelerometer (acceleration + gravity)

      - I just did a quick test on the hawaiian turtles scene
        - for the samsung note 4 (hardware linear acceleration), it seemed ok, much better than I expected actually
        - for the moto g (NO hardware linear accelerometer), the low-pass filter calculated linear acceleration also worked, but the INITIAL ACCELERATION WAS OVERWHELMINGLY IN THE DIRECTION OF GRAVITY, but quickly stabilized - I wonder if the sample rate should be increased?
        - phone movements for the moto g, created a somewhat larger acceleration effect on the turtles / box2d world; I'm not sure how to get the calculated acceleration to be more in-line with the hardware values, but the note 4 would probably be the best place to start with a comparison
          - ideas: adjust filter.a, attempt higher sample rate, scene acceleration scaling

----------
Thursday 2019-06-20

  CODING

    - fingers crossed, sensors appear to be working correctly. available sensors identified consistently so far and working with onpause/onresume functionality

    - re-coded RUBELayer to use my new JNI sensor code for acceleration
      - it seems to work and I can now take advantage of other sensors if the device supports them
      - acceleration/linear acceleration/gravity x & y negated to be correct
      * this doesn't yet account for landscape orientation (or more complex flipped portrait/landscape)

----------
Wednesday 2019-06-19

  CODING

----------
Tuesday 2019-06-18

  CODING

    RUBE Image***

      D:\code\android_projects\gyrotest\proj.android\app\src\com\ecantalejos\cpp\Gyroscope.java
      D:\code\android_projects\gyrotest\proj.android\app\jni\JNISensorUpdate.cpp
      D:\code\android_projects\gyrotest\Classes\GameManager.h

      ..\cocos2d\cocos\platform\android\java\src\org\cocos2dx\lib\Cocos2dxAccelerometer.java
      ..\cocos2d\cocos\platform\android\jni\Java_org_cocos2dx_lib_Cocos2dxAccelerometer.cpp

    Gyroscope demo

      - I simplified the Gyroscope c++ class so much, it's essentially just one-line wrapper functions calls to the JniHelper methods ..it's almost unnecessary at this point

      * while I put down some things done with this code, it provides a much easier template for creating my own sensor code when compared to the cocos2d-x implementation for acceleration


  JNI - added to notes from "Sunday 2019-06-16"

----------
Monday 2019-06-17

  MISC

    - ORDERED A REAL-LIFE DASHBOARD HULA DOLL (kc hawaii) from amazon in order to improve box2d physics, hopefully mimicking real-life motion and spring response
    - back up gyro demo source code to github; I've already changed the original code quite a bit and I plan on making additional modifications as I'm learning jni+android sensors

----------
Sunday 2019-06-16

  CODING

    gyro demo

      - building onto this to figure out JNI usage
      - further tweaked actual gyro code, but there's still just a tiny amount of drift
      - added ON-SCREEN LOGGING capability (RUBE / iforce2d code sample)


    JNI (see list from "Friday 2019-06-14")

      * NOTE: this is MUCH MORE COMPLICATED than what I'm intending with the cocos2d-x framework; I'm pretty sure I'm just scratching the surface..


      GET .JAVA METHOD SIGNATURES

        - in order to CALL JAVA CODE FROM C++, the METHOD SIGNATURES must be determined
        * NOTE: android studio kinda helps with some auto-fill intellisense (see "rube_loader_image" project - SensorManager.cpp)
        
        1) FIND THE "JAVAP" COMMAND in the Android Studio install directory (ex. C:\Program Files\Android\Android Studio\jre\bin)
        2) LOCATE RELEVANT JAVA .CLASS FILE(S) - use file search to locate in the cocos2d-x android studio sub-directory
        3) USE THIS COMMAND TO GET THE REQUIRED SIGNATURES: javap -s <.class file location>


      Cocos2dxActivity (AppActivity.Java)

        - this is created by default as part of the cocos2d-x framework

        - I'm not sure of it's importance yet, but is used differently by 2 different code samples to do kinda similar things related to the running cocos2d-x application

          "Building Android Games" ch.8 : modified to retrieve android cocos2d-x instance to display "toast" message

          Gyroscope sample code : cocos2d-x "context" for initiating access to device sensors


      C++ => JAVA : COCOS2D-X JniHelper (BUILT-IN)

        ..\cocos2d\cocos\platform\android\jni\JniHelper .h/.cpp

        **** IF POSSIBLE, MAKE SURE TO ALWAYS USE THIS ****

        - basically a MUCH FRIENDLIER WRAPPER for using more common calls to jni.h
          - jni.h is a complex system header file for interfacing c++/java (not specific to android)

          *** in the gyro demo, for example, using the method "cocos2d::JniHelper::callStaticVec3Method(CLASS_NAME, "getAccelValues")" greatly simplified the code in Gyroscope::getRate() to be just ONE LINE instead of TWELVE+


      JAVA => C++ (EDIT: Tuesday 2019-06-18)

        - referring to:

          http://stnguyen.com/cocos2d-x/call-cpp-functions-from-java.html
          https://discuss.cocos2d-x.org/t/call-c-function-from-java/27255/2
          Cocos2dxAccelerometer.java (cocos2d-x API)

        - steps 1/2 in the source java (java native functions call matching C functions in step 3)
          - location: D:\code\android_projects\gyrotest\proj.android\app\src\com\ecantalejos\cpp\Gyroscope.java

        - step 3 - create 'extern "C"' c++ binding
          - name/location of the .cpp file isn't important
          - I think the project JNI folder might be a good location as this is android-specific.. maybe or maybe doesn't matter..

        - COCOS2D-X LISTENERS

          for cocos2d-x, a listener seems required, at least for the way the framework implements acceleration
            - this is the "right" way, however..
            - cocos2d-x acceleration > CCLayer.cpp ::setAccelerometerEnabled sets up a listener on an inherited method "Layer::onAcceleration"
            - static java methods need a "java runnable" (I think) as implemented by cocos2d-x internally for handling acceleration..

          * NOTE: I DECIDED TO NOT USE LISTENERS.. WHY?
            - implementing listener logic seems like too much extra code
            - for each sensor I want to use, I would have to implement unique listener code
            - I would have to modify the cocos2d-x framework code --- AND THAT'S VERY INVOLVED AND COULD BREAK THINGS

          - gyro (original demo) does a "polling" from c++ to java to retrieve gyro sensor data
            - this seems inefficient, especially considering that the original did a request for each x, y, and z separately
            - based android docs, you want to minimize traversing c++/java as much as possible


      MISC

        "Building Android Games" ch.8
          - while looking at the source code from JNI example and trying to run it -- it failed - I FORGOT TO COPY OVER SOME OF THE .JAVA FILES; once working, I copied this to my new dev environment

          * of particular note, is that APPACTIVITY.JAVA IS MODIFIED to support the "Android Toast"

----------
Saturday 2019-06-15

  CODING

    JNI - started looking at implementation notes

  
    gyro demo

      USE THIS CODE (though a little "sloppy"), in addition to cocos2d-x template and JNI book notes to create my own "sensor code"

      - tried different code on the moto-g to see if the gyro and/or the linear accelerometer exist -- THEY DON'T!!
        - I was hoping that the linear accelerometer existed on this older device, but no luck ..I'LL HAVE TO PROGRAM THE LOW-PASS FILTER ALSO

      - here's what is available on the moto-g using "..sensorManager.getSensorList(Sensor.TYPE_ALL)"

        3-axis Accelerometer | android.sensor.accelerometer (ACCELERATION + GRAVITY)
        AK8963 3-axis Magnetic field sensor | android.sensor.magnetic_field (GEOMAGNETIC FIELD - ..COMPASS)
        AK8963 Orientation sensor | android.sensor.orientation (DEGREES OF ROTATION AROUND X/Y/Z)
        CT406 Proximity sensor | android.sensor.proximity (HANDSET POSITION DURING A CALL..)
        CT406 Light sensor | android.sensor.light (AMBIENT LIGHT LEVEL)
        Display Rotation sensor | (???)

      - hp touchpad (api level 15)
        - also, tested my rube_loader_image app

        LSM303DLH 3-axis Accelerometer
        LSM303DLH Magnetometer
        ISL29023 Light sensor

      * so in order to actually use the demo, I could only use the samsung note 4 - as that has a gyro sensor
        - I tried to get away with using the ORIENTATION SENSOR (software according to android docs) in place of the gyro, but that's slower / choppier and didn't really work as expected.. anyways I won't really be needing the gyro in the near future per se
        
        COMMENT: something seemed off with this demo, so I tried debugging it
          - in the main update, the gyro rate is rad/s and the update happens ideally at 60 fps - so the rate needs to be divided by 60 (I should have used the delta...) and also needed to be converted to degrees -- THAT SEEMED TO "FIX" THE DEMO
          - there's also a noticeable drift in the rotation readings when still - this could be calibrated out I guess

----------
Friday 2019-06-14

  CODING

    SENSORS (GYRO)

      project cloned from github in hopes of using additional sensors
        - in this project the gyro is supposed to control a 3d sprite
        - https://github.com/Undume/Gyroscope-Cocos2d-x

        - created "helloworld" cocos2d-x project and copied over required files, but the initial test didn't work.. the 3d sprite loaded though
          - I forgot the to copy over the .java files, but then it still didn't work
          - comparing the gyro code to the cocos2d-x acceleration implementation, this doesn't appear to be using the "JAVA ==> C++ CALLBACK" mechanism

        - looking at cocos2d-x built-in accelerometer code @ "..\cocos2d\cocos\platform\android\java" to see if I can reverse debug the gyro project based on this

          - OOF! there's a lot of supporting code for this JNI accelerometer (AND IT'S HARD TO EVEN FOLLOW WHAT'S GOING ON..)
            ..\cocos2d\cocos\base\CCEventListenerAcceleration .h/.cpp
            ..\cocos2d\cocos\base\CCEventAcceleration .h/.cpp
            ..\cocos2d\cocos\platform\android\CCDevice-android.cpp (JAVA HELPER CLASS NAME)
            ..\cocos2d\cocos\platform\android\jni\Java_org_cocos2dx_lib_Cocos2dxAccelerometer.cpp (JAVA ==> C++ CALLBACK?)
            ..\cocos2d\cocos\platform\android\jni\JniHelper .h/.cpp (USEFUL)
            ..\cocos2d\cocos\platform\android\java\src\org\cocos2dx\lib\Cocos2dxAccelerometer.java
            ..\cocos2d\cocos\platform\android\java\src\org\cocos2dx\lib\Cocos2dxGLSurfaceView.java

            ..\cocos2d\cocos\platform\android\java\src\org\cocos2dx\lib\Cocos2dxHelper.java
              - private static Cocos2dxAccelerometer getAccelerometer()
            
        * I eventually got the gyro code to work! I used code to list all of the available sensors on the phone from this code example (https://developer.android.com/guide/topics/sensors/sensors_overview) and discovered that my moto-g doesn't appear to even have a gyro sensor (or at least it fails the check); I tried this against my Note 4 and the gyro suddenly worked (it also lists many more sensors!)
        - I'll continue from here, but I noticed right away that the linear-accelerometer isn't listed on the moto-g (I might have to use the low-pass filter algorithm as a fallback maybe?)
        * also, just a quick reminder - the cocos2d-x implementation, while complex, has some advantages to check out..
            

    AUTO VERTICAL ALIGNMENT

      - I tried looking at sprite info in the layer itself, but that x/y/w/h data was identical to what I found yesterday; at this point, nothing can be done except use an estimatated height offset proportion. here's a sample used in the hellokitty screen init():

        info.b2world_offset_y = Director::getInstance()->getWinSize().height / 4;

      - EDIT 2019-06-15: TODO - upon further reflection, I think I'll attempt to put the NORMALIZED height % in the RUBE file and try to export that in the RUBE json export and use that for positioning. it will be easier to visually estimate the content height based on the RUBE editor layout grid
      - EDIT 2019-07-02: use BOTH normalized design height % AND normalized design width %


  MISC

    - updates for windows 10 and performed backup

    - backed up project "rube_loader_image" on github

      - used .gitignore to create an "essential files" subset of the entire project

      * used VS CODE (to create the initial git local repository and .gitignore) and then GITHUB DESKTOP (create github remote repository)
        - though the command line could have been used, visual tools are more intuitive and pretty easy using this method

----------
Thursday 2019-06-13

  CONTROLLING ORIENTATION / VERTICAL CENTERING

    - I tried looking into PROGRAMMATICALLY CHANGING THE ORIENTATION from landscape to portrait and visa-versa, but this ISN'T POSSIBLE WITHOUT USING THE DEVICE-SPECIFIC API CALLS. in addition, the startup code in AppDelegate is very dependent on the start orientation. I don't really need to switch orientation on-the-fly anyway as I'll just be testing RUBE scenes side-by-side in development.

    * I also DIDN'T HAVE SUCCESS AUTOMATING THE VERTICAL ALIGNMENT. I'm not sure if it's because I'm using the polygon spritesheet or what, but I gave up. it's probably easier to guesstimate the PROPORTION OF THE TOTAL SCENE CONTENT HEIGHT VS THE RUBE DESIGN HEIGHT and then use that proportion against Director::getInstance()->getWinSize().height. this should then work for either portrait or landscape.


  CODING

    - implemented a GAMEMANAGER SINGLETON CLASS
      - in lieu of a Globals file, any globals will be implemented here


  DEVICE LOGGING
  
    - code ripped from: http://www.iforce2d.net/cc2dxres/screenlog

    - implemented as part of the GameManager singleton

    - modified to allow (initial) log placement in pixels-x and screen-y % (this is % of the vertical screen height ..kind of strange, but I'm just trying to stick with the convention of the code already in place)

    - "fixed" DEPRECATED CODE

    COMMENTS: 

      - by design, this LOGGING MECHANISM CAUSES EXISTING LOG MESSAGES TO SCROLL UP AS NEW LOG MESSAGES ARE ADDED; which is fine, but each log message doesn't stay pinned to a fixed location as I initially expected - like a plain label (MODIFYING THIS CODE TO ACT THIS WAY PROBABLY WOULDN'T BE A GOOD IDEA)
      - log messages "disappear" after a specified delay
      - a reference to any log message can be created and the LOG MESSAGE STRING UPDATED
      - a helper class, ScopeLog, can be used as an object lifecycle trace mechanism

----------
Wednesday 2019-06-12

  MISC

    - cocos2d-x v3.17.2 released
      - hold off upgrading for now


  CODING

    - hello kitty hula girl
      - basically the same as the original hula girl with modified sprites and adjustments to RUBE/box2d
      - added hello kitty and "Exit" options to the main menu

    - keep screen on
      - cocos2d-x api call in the RUBELayer constructor/deconstructor
      - RUBELayer is a good central point for this feature as it's used by all box2d physics scenes
      - tested OK while driving briefly today on 2 devices
      - non-RUBELayer scenes such as the main menu isn't affected

----------
Tuesday 2019-06-11

  MISC

    - hello kitty "hula dancer" image prep

----------
Monday 2019-06-10

  USER CONTROLLED TOUCH-BASED MOTION

    - some additional thoughts..
      + box2d body induced wobble using a "FINGER TAP"
      + box2d induced world acceleration using a "FINGER SWIPE"
      + ability to turn each touch input method ON/OFF
      + multi-touch?
      - tweak the mouse joint to break once the position is outside the body
      - a boolean flag of some sort (or maybe the collision filter) on box2d bodies to control if the body is controlled by touch input


  DRIVE TESTING

    - while the "app" is still pretty bare-bones right now, I did attempt to use it during a recent drive to get a better feel for each scene's response to acceleration during a typical drive. for the most part, each physics scene didn't really move very much - disappointing visual appeal. the sandals scene is the most responsive because of it's box2d spring settings, but even that one is underwhelming. in order to tune these visual effects so that they are MORE EXCITING, I need to try a few things.

      - PROGRAMMED WOBBLE RESPONSE using impulse, force, torque, etc.
      - INDUCED X-AXIS WOBBLE by y-axis / z-axis / normalized linear acceleration
      - INDUCED OR AUTO-MOTION AT IDLE
      - LINEAR ACCELERATION from android/ios sensors (see gyro github OR low-pass filter)
        - gyro github project would be ideal for gyro sensor(?) and ambient light for possibly down the road
      - SIDE-BY-SIDE TESTS of different induced wobble methods and/or modified box2d composite entity settings
      - ON-SCREEN LOGGING

  MISC

    - found some good HELLO KITTY images on ebay to possibly use in the future. I want to create ONE sample hula dancer for my test app

    - briefly looked at 2d animation software. 

      Pencil2D - http://www.pencil2d.org/
      Synfig Studio - https://synfig.org/
      Blender (grease pencil)
      Krita

      - have a look on the android play store also

----------
Sunday 2019-06-09

  WHAT'S NEXT? drive testing / programmed movement contol, live wallpaper, ads test, settings, more scenes


  MISC

    - for GIMP > TexturePacker > RUBE graphic and scene creation, these need to be placed in the same folder for simplicity when switching between the 3 of them and android studio

    - when creating fixtures in the RUBE editor, try simplifying the vertices as much as possible. scaling complex bodies with too many vertices often generate errors, especially when scaling to a smaller size.


  CODING

    test app with 4 RUBE/box2d scenes

      - accelerometer works more or less, but settings have to be customized for each scene. the turtles scene for example, would greatly benefit from linear acceleration. the hang loose scene needs programmatic control of the torque in response to acceleration. also movement tests are needed - see TODO list.

      - I built a debug app apk still in the early stages and tested on 3 devices. also cc'd Jack a copy for his thoughts and to see if the debug APK side-loads on his phone


    accelerometer "noise"

      - I think I want to eliminate "noise" on the accelerometer readings and I created an experiment to obtain the min/max/range raw accelerometer data. I ran this test on 3 android devices for about 30-40 seconds each time
      - I'm not sure if removing noise is necessary though..

      TODO: move "noise" test to it's own scene and display on device

      - max range: 0.12400000 (moto g)
      - min range: 0.00952474 (galaxy s3)

      - typical range:
        - varies quite a bit
        - orientation seems to affect the range, as does the device

      moto g (portrait orientation):
        X RANGE:   0.12000000 0.04800000 0.12400000
        Y RANGE:   0.04400003 0.04800004 0.04800004
        Z RANGE:   0.11600000 0.12399998 0.11599997

      moto g (landscape orientation):
        X RANGE:   0.04400003
        Y RANGE:   0.12400000
        Z RANGE:   0.04800001

      note 4 (portrait orientation):
        X RANGE:   0.01708984 0.01513672 0.01513672
        Y RANGE:   0.02343750 0.02343750 0.03271478
        Z RANGE:   0.02587891 0.02441406 0.02880859

      note 4 (landscape orientation):
        X RANGE:   0.01953119
        Y RANGE:   0.01318360
        Z RANGE:   0.01855469

      galaxy s3 (portrait orientation):
        X RANGE:   0.01196698 0.01025741 0.00952474
        Y RANGE:   0.08364666 0.03235966 0.03736627
        Z RANGE:   0.01599663 0.01367652 0.01269966

----------
Saturday 2019-06-08

  MISC

    - update calendar

    - review journal 2019-05

      stats:
        - journal start: 2018-10-07
        - total: 95/250 based => 38%
        - may 2019: 24/31 days => 77%

    
  TODO list

    - looking back at my notes, it might be worth trying to use a MOTOR JOINT with my turtles scene (see journal Thursday 2019-05-30)

    * I think I need to look back over my notes / comments (did I take notes?) for my iforce2d tutorial tests in the box2d test harness created in visual studio 2019
      + take a look at the pre-built tests (see journal entry Monday 2019-05-20)

    - I need to create a new journal for each project: separate folder, features, change log, issues..


  COCOS2D-X "GLOBAL" VARIABLES

    - curious about global variables in cocos2d-x, I'm sure I've read about this before

    globals class (EDIT 2019-06-13: GLOBAL SINGLETON - LIKE THE GAME MANAGER - IS PROBABLY BETTER HERE; NO LUCK WITH THIS IMPLEMENTATION)
      - https://discuss.cocos2d-x.org/t/global-variables-in-cocos2d-x/20176/11

    game manager singleton
      - https://discuss.cocos2d-x.org/t/global-variables-in-cocos2d-x/20176/8
      - https://discuss.cocos2d-x.org/t/correct-way-to-implement-singleton/28226/16
      * https://discuss.cocos2d-x.org/t/correct-way-to-implement-singleton/28226/23
      - https://discuss.cocos2d-x.org/t/correct-way-to-implement-singleton/28226/34

    userdefault
      - https://docs.cocos2d-x.org/api-ref/cplusplus/v3x/db/d94/classcocos2d_1_1_user_default.html


  CODING

    - coded android back button functionality
      * NOTE: there needs to be an on-screen button to duplicate this, especially for IOS

    - attempt to integrate accelerometer into RUBELayer .h/.cpp; when trying to test, the scaling and/or the physics settings are completely off

----------
Friday 2019-06-07

  bobble app

    - created a main menu for "Hang Loose", "Hula Girl", "Sandals", and "Hawaiian Turtles" with scenes for each


  - physics RUBE scenes prepped for "turtles"

    - most of the time spent creating the body/joint settings for a decent range of motion for the fins with appropriate mass for reasonable movement just using the mouse joint
    
    - while making these RUBE scenes, a question comes to mind - IS THERE AN OPTIMAL B2WORLD DESIGN SIZE?

      - for things falling, etc. where gravity affects perceived velocity this might be an issue (?)
      - I've been designing objects at a b2World screen height of ~10-20 m (I think), but that makes some of these "toys" rediculously large! size is relative in box2d worlds though

      * so if 20 large box2d units equates to 20 m this ends up around 6 stories IRL, and that would equate to a 2-3 story hula dancer, etc. (this is based on the assumption that 1 large box2d unit = 1 meter)

      - an alterative, is to design each RUBE scence to a 4 "METER" BOX2D SCREEN HEIGHT. the phone screen would equate to only a 1 story building, with objects equating to the height of a car. I think this might be more reasonable
        - after making my early proof-of-concept app, I think I'll go back and re-size the box2d scenes to this height

    - for the screen-to-visible-world, I'm using an image overlay of different aspect ratio phone screens, with the target being a narrower device aspect ratio as newer phones seem to be targeting this design

----------
Thursday 2019-06-06

  - physics RUBE scenes prepped for "hang loose", "sandals"; "turtles" started
    
    - tested "sandals" in same app as the "hula dancer" ..and this worked much better than expected

----------
Wednesday 2019-06-05

  - prepped images for "hang loose", "sandals", and "hawaiian turtles"; these still need the physics scenes built in the RUBE editor


  GIMP layer masking video tutorial

    - useful for things like hair

    - add transparency (alpha channel) to layer

    - duplicate layer and rename to "mask"

    "mask" layer:
      + colors > curves (CONTRAST METHOD 1)
        - increase contrast between "hair" (or shape edges) and background by adjusting slope to bottom-flat>steep>top-flat so background is almost white and contrast has large as possible

      - colors > desaturate (b&w)
        - choose best mode for contrast

      + colors > brightness-contrast (CONTRAST METHOD 2)
        - adjust both to where fine features (ie. individual hairs) can be seen

      - colors > invert (to create a negative)

      GOAL: anything black is removed and anything white is kept

      - choose paintbrush
        - increase brush size
        - paint over areas that the mask should not remove WHITE
        - paint areas outside the primary shape BLACK
        - use hide/show mask layer to see what is and isn't part of the intended mask

      ??? use soft brush on mask edges OR soften the edge of an existing layer mask, you could just use Filter >> Blur >> Gaussian Blur

      *** TIPS (2019-08-02) - use FUZZY SELECT TOOL for the paintbrush step, with CTRL / SHIFT ***

      - edit > cut (removes entire layer into clipboard)

    original image layer
      - layer > mask > add layer mask (OR right-click > add layer mask)
        - dialog select: "white (full opacity)"

      - select layer mask icon (2nd square next to original image)

      - edit > paste (a floating pasted layer is created)
      
      - right-click new floating layer > anchor layer (mask negative should be visible in 2nd square)

    - create a new layer behind the newly masked image and fill with contrasting color and zoom-in on edges to note mask problems
      - select original image square and use clone tool (and/or the burn tool {burn+highlights}) to fix problem edge areas

    - save gimp file for later modification and export

----------
Tuesday 2019-06-04

  b2dJson image load test project ==> DASHBOARD TOY APP

    - able load TEXTUREPACKER SPRITESHEET (awesome!) OR individual image sprites

    - this "test" project is turning into my actual app I think, right now it's just one scene, but it establishes a streamlined workflow for adding additional scenes

      SIMPLIFIED WORKFLOW:

        1) create or obtain images
        2) use TexturePacker to create an optimized spritesheet & .plist
        3) use RUBE editor to create physics scene using the standalone images & export to .json
        4) re-create the physics scene with my new "RUBELayer" class to load RUBE physics .json file (b2dJson) and TexturePacker sprites
        5) customize each individual scene

        - also, to simplify the directory/file resource management, try keeping all files in the same directory

  RUBE editor / Box2D

    - so in case I forgot to journal this, it's possible to create "composite" joints to mimic real-world physics objects; this is accomplished by super-imposing box2d joints on top of one another. I have 2 RUBE editor file examples that I created:

      "COMPRESSION SPRING" (see compression-spring.rube): by attaching a prismatic and distance joint on the same 2 bodies, I can create something that acts like a regular compression spring of sorts - it's limited to movement along a single axis

      "ROTATIONAL SPRING" (see hula.rube): by attaching a revolute and weld joint on the same 2 bodies AND exactly the same position I was able to create a rotation spring limited to a fixed min/max angle

    - I did this because the default joints on their own, don't always meet my needs, so this seems like a reasonable solution that require NO ADDITIONAL CODING

    - also, I was thinking of creating a spring-like object that can compress/elongate/rotate by either combining the above OR a pseudo spring composed of multiple weld joints that look like a side-view spring in 2D (I actually tried this in the RUBE editor and it failed miserably. the simulation resulted in super-wacky oscillations with each additional joints+bodies added)

----------
Monday 2019-06-03

  CODING

    - RUBE + images now load into android using b2dJson
    - customized RUBE layer from demo created; now it's just one class, highly re-usable and simplified loading of new RUBE json scenes, but still needs improvements

----------
Sunday 2019-06-02

  CODING

----------
Saturday 2019-06-01

  MISC

    - new journal for June 2019 created
    - install GIMP image software v2.10.10

  CODING