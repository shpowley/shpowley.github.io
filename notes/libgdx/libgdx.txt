TRAINING

  UDACITY: 2D GAME DEVELOPMENT WITH LIBGDX (FREE)
    https://classroom.udacity.com/courses/ud405

    github course content: https://github.com/udacity/ud405

    @lesson 1.68 - accelerometer input

    starfield
      - shapeRenderer .dot()

    connect the dots
      - shapeRenderer .polyline()
      
      dot generator
        - bonus project used to actually create the dots, libgdx "InputProcessor", desktop only, R (reset), L (log)

    CAMERA viewport demo
      - 2 cameras: overview + controllable
        - overview camera contains outline of controllable
        - controllable can actually zoom out and pan past the overview

      * THIS MIGHT COME IN VERY HANDY
        - code is a bit more involved (NOT EXPLAINED), but still manageable

      COMMANDS
        arrow keys: move controllable
        space: switch between overview / controllable cameras
        z: zoom in controllable
        x: zoom out controllable
        w/s: controllable height
        a/d: controllable width
        f: reset controllable height/width aspect
        q/e: controllable rotation

    solar system demo
      - first explanations of CAMERA
      - note .resize() handles android screen rotations, desktop screen window size adjustments

    viewport demo
      - intro to different types of camera viewports
      - interesting, but would this be used to accomplish something similar to the "camera viewport demo"
        - comment: world w/h + camera.translate() + viewport.update(..., false)?

    smiley face exercise
      - combines renderer, shapes, colors, viewport + viewport positioning

    text demo
      - bitmap font intro, sprite texture filtering

    word cloud exercise
      - bitmap font color, size..

    circular motion
      - introduces elapsed time using TimeUtils.nanoTime()
      - circle rotation + fancy circle pattern (I'm not sure how this is done)
      - equations from https://www.mathopenref.com/coordparamcircle.html

    reciprocating motion exercise
      - similar to circular motion demo, but just the x-motion component and minus the fancy circles

    games and screens demo
      - introduces game and screen concepts ...Gdx.graphics (fps, delta time usage)
      - switching 2 screens: fps, interval

    screen saver exercise
      - sub-component render (used previously also)
      - small use of input processor

    input testbed
      - working demo template of a single bouncing ball that slows down due to drag/friction and get new kicks to propel it after a short delay
      - game "template" gets more refined
      - introduces "ScreenAdapter", .setAutoShapeType()
      * .dispose() method still gets used.. I thought the recommendation was to use the .hide() method, but maybe this is only necessary if there's multiple screens

    polling demo
      - continue previous ball "input testbed" by adding KEYBOARD POLLING
      - "Z" grows ball, "X" shrinks ball

    polling exercise
      - build on "polling demo" by adding UP/DOWN/LEFT/RIGHT + max velocity clamp

    input adapter demo (input event)
      - builds on "polling exercise
      - extend InputAdapter class
        - override keyDown() to create the ball "kick"
      - register new InputProcessor with libGDX
      - note that Z X UP DOWN LEFT RIGHT still work using the polling method

    reset ball game state exercise

    demo flick
      - control ball "kick" direction + velocity with "flicks"
      * note that this code isn't really a "flick" as the resulting code/execution is solely based on the direction/distance of beginning and end touches (THIS IS MORE LIKE A "SLINGSHOT" THAT CAN BE AIMED)
      
    follow the finger
      - building on "demo flick" to move the ball to the finger/mouse position

      NOTES:
        - I got the incorrect on some portions using Vec2 .set() and Vec2 initialization
        - the MAIN LESSON TO TRY AVOIDING UNNECESSARY VEC2 creation/method calls whenever possible
        - viewport .project()/.unproject for example only deal with Vec2/Vec3 -- REQUIRED HERE
        - object overhead for storing x/y/z coordinates -- USE PURE FLOAT VARIABLES
        - also, avoid Vec methods unless necessary.. hides inner workings + extra calls
        - .touch methods could be more efficient by not creating new Vector2() objects each call

    accelerometer input demo
      - biggest take-away is that this demo uses 2 viewports, 1 for graphics (FitViewport) and 1 for text (ScreenViewport)

    bubble level exercise
      - not 100%, but accelerometer axis readings may be skewed by 90 degrees because of landscape game orientation ..so x/y axis reading are swapped
      - also, once swapped, the new vertical y-axis readings are inverted

    accelerometer movement exercise
      - builds on "follow the finger" code adding accelerometer x/y as an additional mechanism to control ball
      - not really sure of the reasoning for the ball acceleration logic..

    CREATE THE ICICLES PROJECT
      - use the libGDX java setup program
      - ending up using the android studio JRE (took a while to find it though)
        - had to set the JAVA_HOME environment variable and add it to the windows PATH

      - open project directly in android studio -- IMPORT not specifically required
      - update gradle plugin to the latest stable -- THIS WORKED unlike the existing UDEMY project files


  OTHER TRAINING

    UDACITY: how to make a platformer using libgdx (free)


    3d and libgdx
      https://xoppa.github.io
      https://xoppa.github.io/blog/basic-3d-using-libgdx/

    youtube / foreignguymike
      https://www.youtube.com/c/ForeignGuyMike/featured

    youtube / brent aureli
      https://www.youtube.com/c/BrentAurelisCodeSchool/featured

    youtube / dermetfan
      https://www.youtube.com/c/dermetfan/featured


    libgdx.com getting started
      https://libgdx.com/

    libgdx (official??) > getting started
      https://libgdx.badlogicgames.com/index.html

    libgdx wiki *** MAKE SURE TO READ THROUGH ***
      https://github.com/libgdx/libgdx/wiki


    live wallpaper
      https://molotuspi.blogspot.com/2013/09/how-to-make-simple-android-live.html


MISC

  LibGDX javadocs - VERY USEFUL
  ApplicationListener vs ApplicationAdapter
  Gdx.app.log()


DOCUMENTATION + JAVADOCS

  https://libgdx.com/dev/

  
ANDROID STUDIO RUN CONFIGURATIONS

  from the android terminal:

    linux/mac:
      $ ./gradlew desktop:run

    windows:
      $ gradlew desktop:run

    * use CTRL+ENTER to get correct IDE environment variables


  run configurations:

    - accessible only via the toolbar?
    - default run config is android
    - for desktop (and other types), make sure to fill out the lines for GRADLE PROJECT and TYPE


SHAPE RENDERER (shapeRenderer CLASS)

  - BATCH draw commands to graphics
  - START/STOP BATCH draw commands when switching between filled/outline modes
  - shapes stack with last drawn on top


  NOTEABLE METHODS

    .setColor()
    .line()
    .polyline()
    .rect() : many overloaded versions, vertex colors, rotated rectangles
    .rectline() : thick lines
    .circle()
    .arc()


CAMERA

  OrthographicCamera CLASS
    - based on Camera CLASS

    orthographic - 2-dimensional projection of 3-dimensional objects and world


  VIEWPORT
    - helps control camera aspect ratio

    - note viewport "world" vs "screen" terminology (I think..)
      - "world" refers to virtual viewport coordinates
      - "screen" refers to actual pixel


    pre-made viewport sub-classes
    
      StretchViewport
        - WORLD IS SCALED to take the whole screen, but DOESN'T RESPECT ASPECT RATIO

      FillViewport 
        - world fill the screen, maintaining aspect ratio, but bits of the WORLD MAY BE CLIPPED

      FitViewport 
        - world fills the screen, maintaining aspect ratio, but ADDS BLACK BARS (LETTERBOXING) for the remaining space
        - good choice but may look bad on certain devices

      ExtendViewport
        - short axis of the world fills the screen, maintaining aspect ratio
        - almost always the best choice

      ScreenViewport
        - world size is based on the size of the screen, pixel-per-pixel (ratio can be changed)


TEXT

  BITMAPFONT

    - requires SpriteBatch


TIMEUTILS / FRAME RATE

  TimeUtils.millis()
  TimeUtils.nanoTime()

  - .nanoTime() is typically used for elapsed time from application start


SCREEN
  - create/dispose of objects using .hide()/.show() methods instead of .dispose() due to multiple game screens..


INPUT

  POLLING

    - test for individual keys
      
      .update() > Gdx.input.isKeyPressed(Keys.<KEY OF INTEREST>)


  EVENTS

    - extend InputAdapter class + override appropriate EVENT (ie. keyUp(), mouseMoved(), etc.)
    - also make sure to register new InputProcessor with libGDX
      
      ie. Gdx.input.setInputProcessor(ball);


  TOUCH

    - supports multi-touch
    - part of the InputAdapter class
    - viewport.unproject() is needed to handle SCREEN TOUCHES -> VIEWPORT COORDINATES


  SENSORS

    Gdx.input

    - built-in: accelerometer, gyroscope, compass
    - buffered data?
    - actual code implementation appears hidden
    * application/game orientation may affect swapping of final x/y axes
    * some axis reading may need to be inverted 